---
title: 算法：回溯
date: 2022-06-21 21:33:04
tags:
categories: 算法
---
## 概述

通俗上讲，回溯是一种走不通就回头的算法。

回溯的基本思想：通过DFS遍历探索所有的可能性，记录或者返回满足条件的情况

通常构建决策树（sate space tree），然后用 DFS 递归地遍历决策树。

具体到每一步

- 考虑当前元素，更新状态值。
- 判断是否满足结果条件，满足则加入结果集然后返回；
- 不满足则继续探索**所有**的可能性。即决策树中每个子节点
- 每次递归调用之后都要恢复状态值（undo）

此外，回溯问题常伴随着对结果的**限制条件**，即**用来剪枝的条件**

需思考如何在递归过程中用代码实现剪枝条件

> 🍋 所以回溯算法常用来解决**列出所有可能解**的问题，用**DFS**列出状态树

## 问题类型

回溯问题通常需要分多步，每一步有多种选择，要求找到**所有**满足要求的结果

常见问题类型有

- 组合问题（子集）
- 排列问题
- 其他形式的需要列举所有满足条件的情况问题。有时可以转换成排列组合问题，如经典的N皇后

### 递归图示

一个递归
![](1.png)

两个递归（fib）
![](2.png)

n 个递归
![](3.png)


```jsx
// n 个递归
function recursive(input){
	 for () {
		recursive(newInput)
	}
}
```

## 组合（子集）问题 **`combination`**

### 全部子集

问题：给定一个无重复元素的数组，返回所有子集

算法过程描述 ： 分成 n 步，每步考虑**是否选择**第 i 个数加入集合。

当当前下标等于数组长度时加入结果集并返回

时间复杂度O(2^N)

### n 选 k 组合

问题：给定一个无重复元素的数组，从中选出 k 个元素，列出所有可能的组合

算法过程描述 ： 组合问题就是求子集的问题，分成 n 步，每步考虑**是否选择**第 i 个数加入组合。

当已选个数等于 k 时就加入结果集并返回

时间复杂度O(2^N)

### 组合 ：存在重复元素

为题描述： 给定一个数组，存在重复元素，求其所有的子集或者从中选出 k 个元素的所有组合

重点在于**去重**

思想：决策树的剪枝

剪枝的策略： **在一连串的 m 里面，如果第一个 m 没有放入子集，那么后面的 m 都不能放入子集。**

代码实现： **先排序**，**当在某一步决定跳过某个值为 m 的数字时，跳过所有值为 m 的数字。**

![](组合去重.png)

| 问题                                   | 难度 | 备注                                                         |
| -------------------------------------- | ---- | ------------------------------------------------------------ |
| 257. 二叉树的所有路径                  | 🍍    | 基础：DFS，传的是原始类型值字符串，所以不需要undo            |
| 113. 路径总和 II                       | 🍍🍍   | 变式，思路与模板与上题类似。DFS前序遍历的基础上做，这次传的是数组，需要undo一下 |
| 39. 组合总和                           | 🍍🍍   | 变式：需要先构建二叉树，两个递归，选/不选。注意分析base case ，有三个 |
| 78. 子集                               | 🍍🍍   | 组合问题。思路：dfs递归，每一步从集合中取出一个元素，选择加或者不加入组合中 |
| 90. 子集 II                            | 🍍🍍   | 组合问题 + 避免重复。 思路：在上一题的基础上，先排序，当在某一步决定跳过某个值为 m 的数字时，跳过所有值为 m 的数字。所以先排序再操作 |
| 剑指 Offer II 080. 含有 k 个元素的组合 | 🍍    | 组合问题，与子集做法类似                                     |
| 216. 组合总和 III                      | 🍍🍍   | 变式：由k个元素组合，和求和问题的结合，先转换问题            |


## 排列问题`permunation`

### 全排列问题

问题描述：输入一个包含 n 个无重复元素的数组，输出所有全排列

思路：类比**子集**问题，子集问题分 n 步， 每次决策决定是否将第 i 个数加入子集，因此每次有两个分支，选或者不选

无重复的n 个数进行全排列，分成n步。每次决策决定选择排列的第 `i` 个数是什么。第一次由 n 种选择， 第二次由 n-1 种选择，以此类推

根据思路画出决策树

注意点：用什么来维护备选的数？

- 方法一：用一个 visited 数组记录已经选择过的数
- 方法二：原地修改数组元素位置，将数组分成两部分： 选过的数和未选过的数

![](4.png)
![](5.png)
![](6.png)

```jsx
/**  方法二 代码，优雅
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    //另一种方法，原地修改数组来记录访问过和未访问过的元素
    let res = [] 
    dfs(nums, res, 0)
    return res 
};

function dfs(nums, res, separate) {
    if (separate === nums.length) {
        res.push([...nums])
        return 
    }
    for(let i = separate; i < nums.length; i++) {
        swap(nums, i, separate) //从剩下的数中选一个
        dfs(nums, res, separate + 1)
        swap(nums, i, separate)  // undo
    }
}

function swap(nums, i, j) {
    let temp = nums[i]
    nums[i] = nums[j] 
    nums[j] = temp
}
```

### n 选 k 排列

将递归条件改为 当已选元素个数达到 k 时就返回 即可

### 全排列：存在重复元素的情况

问题描述：给定一个数组，存在重复的元素，输出全排列

思想：同样是剪枝

剪枝的策略：**在某一层决策中**，如果选择一个数 m 作为排列的第 i 个位置，那么后面再遇到 m 直接跳过

代码实现：使用一个 set 来记录访问过的数字

| 问题          | 难度 | 备注                                                         |
| ------------- | ---- | ------------------------------------------------------------ |
| 46. 全排列    | 🍍🍍   | 基础，无重复元素的全排列。使用visited数组记录已使用过的元素  |
| 47. 全排列 II | 🍍🍍🍍  | 变式，带重复元素的全排列。在每一层添加Set来记录已经使用过的数字 |

## 剪枝

| 22. 括号生成     | 🐮🐮   | 思路：重点画出决策树，&  剪枝条件。 决策树一共2层，每次只有两个选择。剪枝条件为 ( 的个数必须 ≥ ）的个数 |
| ---------------- | ---- | ------------------------------------------------------------ |
| 93. 复原 IP 地址 | 🐮🐮   | 思路：决策树每次有三个选择，选1个，2个 和 3个； 先写出回溯基本框架，实现之后再添加剪枝条件 |
| 79. 单词搜索     | 🐮🐮   | 有点问题                                                     |
| 51. N 皇后       | 🐮🐮🐮  | 经典回溯问题，先不考虑对角线位置，将问题降；然后考虑剪枝或者叫做边界条件，巧妙地将对角线位置转换为 x+y = C |



## 集合划分

| 问题                            | 难度 | 备注       |
| ------------------------------- | ---- | ---------- |
| 698. 划分为k个相等的子集        | 🍍🍍   |            |
| 47. 全排列 II2305. 公平分发饼干 | 🍍🍍   | 与698类似  |
| 473. 火柴拼正方形               | 🍍🍍   | 一样的题目 |

与子集问题类似，子集问题是遍历每个元素，考虑当前元素是否加入组合。决策树为二叉树

集合划分问题从元素的角度，也是遍历每个元素考虑加入哪个“bag”，决策树为多叉树

重点在剪枝：

- 第一个元素的选择
- **超过平均值**
- **遇到重复元素**     在回溯过程中，如果出现 **comb** 前后相同的情况，则跳过，避免重复考虑相同的组合情况

## 部分题解

***\*[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)\****

理解题意，转换问题 ⇒ 带重复元素的排列问题

画出决策树： 总共做 2n 次决策， 每次只有两种选择，open `(` 或者 close `)`

剪枝条件：什么才是有效的括号组合？ 已选的括号中，open 的个数要大于等于 close

代码实现 ：

```jsx
function dfs(comb, open, close, max, res ) {
//max 代表最多 max 个()组合，决策树深度 2*max
    if (comb.length === 2 * max) {
        res.push(comb.join(''))
    }

    //选择 open
    if (open < max) {  
        comb.push('(')
        dfs(comb,open + 1, close, max, res)
        comb.pop()
    }

    //选择 close
    if (close < open ) { //剪枝条件
        comb.push(')')
        dfs(comb, open, close + 1, max, res)
        comb.pop()
    }
}
```

## 参考

[03 从二叉树遍历到回溯算法 － 小专栏](https://xiaozhuanlan.com/topic/8967023451)

[08 排列组合问题：回溯法的不变式与剪枝 － 小专栏 (xiaozhuanlan.com)](https://xiaozhuanlan.com/topic/7815396402)

[西湖区_回溯](https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/thinkings/backtrack)

[How to Code Combinations Using Recursion - YouTube](https://www.youtube.com/watch?v=NA2Oj9xqaZQ)

[What are Permutations & how do they differ from Combinations? - YouTube](https://www.youtube.com/watch?v=us0cYQXQpxg)

[6 Introduction to Backtracking - Brute Force Approach - YouTube](https://www.youtube.com/watch?v=DKCbsiDBN6c&list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&index=63)   大叔讲算法

